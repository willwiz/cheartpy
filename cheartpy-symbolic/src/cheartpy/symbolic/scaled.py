from .expressions import Expression
from .trait import ALL_TYPES, IMMUTABLE_TYPES, MathOperator, ScaledTrait


class Scaled[T: IMMUTABLE_TYPES](ScaledTrait):
    __slots__ = ("_scalar", "_value")
    _scalar: float
    _value: T

    def __init__(self, scalar: float, value: T) -> None: ...
    def __str__(self) -> str: ...
    def __hash__(self) -> int:
        return hash((self.scalar, self.value))

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, ScaledTrait):
            return False
        return self.scalar == other.scalar and self.value == other.value

    def __neg__(self) -> ScaledTrait | T:
        if self.scalar == -1:
            return self.value
        return Scaled(-self.scalar, self.value)

    def __add__(self, other: ALL_TYPES) -> ALL_TYPES: ...
    def __radd__(self, other: ALL_TYPES) -> ALL_TYPES:
        if isinstance(other, (float, int)):
            if self.scalar < 0:
                return Expression(other, MathOperator.SUB, Scaled(-self.scalar, self.value))
            return Expression(other, MathOperator.ADD, self)
        return other + self

    def __sub__(self, other: ALL_TYPES) -> ALL_TYPES: ...
    def __rsub__(self, other: ALL_TYPES) -> ALL_TYPES: ...
    def __mul__(self, other: ALL_TYPES) -> ALL_TYPES: ...
    def __rmul__(self, other: ALL_TYPES) -> ALL_TYPES: ...
    def __div__(self, other: ALL_TYPES) -> ALL_TYPES: ...
    def __rtruediv__(self, other: ALL_TYPES) -> ALL_TYPES: ...
    def __pow__(self, other: ALL_TYPES) -> ALL_TYPES: ...
    def __rpow__(self, other: ALL_TYPES) -> ALL_TYPES: ...
    def __mod__(self, other: ALL_TYPES) -> ALL_TYPES: ...
    def __rmod__(self, other: ALL_TYPES) -> ALL_TYPES: ...
    @property
    def value(self) -> T: ...
    @property
    def scalar(self) -> float: ...
